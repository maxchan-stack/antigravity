<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Click Sticker V3</title>

    <!-- 引入 React 和 ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>

    <!-- 引入 Babel 用於解析 JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 引入 Framer Motion (透過 UMD) -->
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <!-- 引入 JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- 字體 -->
    <link
        href="https://fonts.googleapis.com/css2?family=Caveat:wght@700&family=Inter:wght@400;500;600;700;900&display=swap"
        rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0E0E0E;
        }

        .bg-grid-pattern {
            background-image: linear-gradient(rgba(191, 163, 124, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(191, 163, 124, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        @keyframes fade-in-down {
            0% {
                opacity: 0;
                transform: translateY(-20px) translateX(-50%);
            }

            100% {
                opacity: 1;
                transform: translateY(0) translateX(-50%);
            }
        }

        .animate-fade-in-down {
            animation: fade-in-down 0.5s ease-out forwards;
        }

        /* StarLux Inspired Button Glow */
        .portal-button {
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .portal-button:hover {
            transform: translateY(-3px);
        }

        .community-link {
            transition: all 0.2s ease-in-out;
        }

        .community-link:hover {
            transform: scale(1.02);
        }

        .chatroom-button {
            background-image: linear-gradient(to right, #2A2A2A, #111);
            animation: pulse-border 3s infinite;
        }

        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 0 rgba(191, 163, 124, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(191, 163, 124, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(191, 163, 124, 0);
            }
        }

        /* Revised Aurora for StarLux - Warm/Gold/Grey */
        .aurora-bg {
            background-image:
                radial-gradient(ellipse 60% 40% at 50% -10%, rgba(191, 163, 124, 0.15), transparent),
                radial-gradient(ellipse 70% 50% at 50% 110%, rgba(74, 93, 79, 0.2), transparent);
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #111;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #BFA37C;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        // 取得 React hooks 和 Framer Motion 元件
        const { useState, useRef, useEffect, useCallback, useMemo } = React;
        // Framer Motion 全域變數通常是 Motion，需要解構
        const { motion, AnimatePresence } = window.Motion;

        // --- 多國語言翻譯 ---
        // --- 多國語言翻譯 (已簡化為僅繁體中文) ---
        const translations = {
            title: 'One Click Sticker V3',
            subtitle: '將您的照片變成獨一無二的聊天貼圖。',
            upload_title: '1. 您的照片',
            upload_click: '點擊以上傳檔案',
            upload_or: '或',
            upload_camera: '使用相機',
            upload_change_file: '更換檔案',
            stickers_title: '2. 選擇貼圖',
            generator_title: '✨ AI 貼圖創意產生器',
            generator_desc: '描述一個主題，或讓 AI 從您的照片找靈感！',
            generator_inspiration_btn: '從圖片取得靈感',
            generator_analyzing: '分析中...',
            generator_placeholder: '例如：我家愛搗蛋的橘貓、辦公室專用...',
            generator_generate_ideas_btn: '產生點子',
            generator_generating: '產生中...',
            select_reactions: '選擇您想生成的反應：',
            back_to_default: '← 返回預設貼圖',
            option_anime: '可愛動漫',
            option_add_text: '加上文字',
            generate_stickers_btn: '生成貼圖',
            generating_stickers: '生成中...',
            remove_bg_btn: '一鍵去背',
            removing_bg: '去背中...',
            remove_bg_desc: '智能去除亮綠色背景，保留人物細節',
            your_generated_stickers: '您生成的貼圖',
            keep_window_open: '生成貼圖時請保持此視窗開啟。',
            start_over: '重新開始',
            download_zip: '打包下載',
            zipping: '打包中...',
            line_store_upload: '上架LINE貼圖',
            history_title: '生成紀錄',
            history_empty: '目前沒有任何紀錄。',
            history_load_session: '載入此紀錄',
            history_delete_session: '刪除',
            history_delete_confirm: '您確定要刪除這筆紀錄嗎？此操作無法復原。',
            history_export: '匯出紀錄',
            history_import: '匯入紀錄',
            history_import_success: '紀錄匯入成功！',
            history_import_error: '匯入失敗。檔案格式不符或已損毀。',
            history_export_error: '匯出紀錄失敗。',
            version_log_title: '版本日誌',
            version_title: '發現新版本！',
            version_message: '偵測到最新版本為 {version}。<br/>建議您更新以獲得最佳體驗。',
            version_update_btn: '跳轉新版本',
            version_old_btn: '使用舊版本',
            error_upload: '請先上傳一張照片！',
            error_select_one: '請至少選擇一個貼圖來生成！',
            error_zip_lib: '壓縮程式庫尚未載入，請稍後再試。',
            error_no_stickers_to_zip: '沒有可以打包的貼圖。',
            error_zip_failed: '建立壓縮檔失敗，請再試一次。',
            error_no_stickers_to_process: '沒有可以處理的貼圖。',
            error_bg_remove_failed: '去背處理失敗，請再試一次。',
            error_ideas_input: '請輸入您的貼圖點子描述！',
            error_ideas_failed: '無法產生貼圖點子，請稍後再試。',
            error_inspiration_failed: '無法從圖片取得建議，請稍後再試。',
            error_regenerate_failed: '為 "{stickerName}" 重新生成失敗。',
            error_db_init: '無法初始化本地資料庫。生成紀錄功能可能無法使用。',
            error_db_save: '儲存生成紀錄失敗。',
            error_db_load: '讀取生成紀錄失敗。',
            error_db_delete: '刪除生成紀錄失敗。',
            error_file_process: '處理檔案時發生錯誤。',
            error_api_key_missing: '請先設定 Google API Key 才能使用此功能。',
            footer_portals: '無限世界',
            footer_resources: '社群應用資源',
            footer_chat: '無限聊天群',
            sticker_happy: '開心',
            sticker_sad: '傷心',
            sticker_laugh: '大笑',
            sticker_angry: '生氣',
            sticker_love: '愛心',
            sticker_ok: 'OK',
            sticker_confused: '問號',
            sticker_sleepy: '想睡',
            sticker_surprised: '驚訝',
            sticker_thinking: '思考',
            sticker_crying: '難過',
            sticker_pleading: '拜託',
            api_key_modal_title: 'API Key 設定',
            api_key_input_placeholder: '請在此輸入您的 Google API Key',
            api_key_save_btn: '儲存設定',
            api_key_get_btn: '取得 Google API Key',
            api_key_description: '為了使用 Gemini 2.0 Flash (Exp) 繪圖模型，請輸入您自己的 API Key。',
        };

        // --- IndexedDB 輔助函式 ---
        const DB_NAME = 'StickerGeneratorDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'generationHistory';
        let db;

        const initDB = () => {
            return new Promise((resolve, reject) => {
                if (db) {
                    resolve(db);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (event) => reject("IndexedDB error: " + event.target.errorCode);
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(STORE_NAME)) {
                        dbInstance.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                };
            });
        };

        const saveSessionToDB = (session) => {
            return new Promise((resolve, reject) => {
                if (!db) reject("DB not initialized");
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.add(session);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject("Error saving session: " + event.target.error);
            });
        };

        const loadHistoryFromDB = () => {
            return new Promise((resolve, reject) => {
                if (!db) reject("DB not initialized");
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result.reverse()); // Show newest first
                request.onerror = (event) => reject("Error loading history: " + event.target.error);
            });
        };

        const deleteSessionFromDB = (id) => {
            return new Promise((resolve, reject) => {
                if (!db) reject("DB not initialized");
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject("Error deleting session: " + event.target.error);
            });
        };


        // --- 輔助函式 ---

        const toBase64 = file => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });

        const cropImageToSquare = (imageBase64) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const size = Math.min(img.width, img.height);
                    canvas.width = size;
                    canvas.height = size;
                    const startX = (img.width - size) / 2;
                    const startY = (img.height - size) / 2;
                    ctx.drawImage(img, startX, startY, size, size, 0, 0, size, size);
                    resolve(canvas.toDataURL('image/jpeg', 0.95));
                };
                img.onerror = (err) => reject(err);
                img.src = imageBase64;
            });
        };


        const fetchWithRetry = (url, options, retries = 5, backoff = 1000) => {
            return new Promise((resolve, reject) => {
                const attempt = async (retryCount, delay) => {
                    try {
                        const response = await fetch(url, options);
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            console.error('API 錯誤:', errorData);
                            if (response.status === 429 && retryCount > 0) {
                                console.log(`請求頻率過高。將在 ${delay / 1000} 秒後重試...`);
                                setTimeout(() => attempt(retryCount - 1, delay * 2), delay);
                            } else if (response.status === 401) {
                                reject(new Error(`API 請求失敗，狀態碼 401：未授權。請確認您的 API 金鑰是否有效。`));
                            }
                            else {
                                reject(new Error(`API 請求失敗，狀態碼 ${response.status}: ${errorData.error?.message || '未知錯誤'}`));
                            }
                        } else {
                            resolve(response.json());
                        }
                    } catch (error) {
                        if (retryCount > 0) {
                            console.log(`請求失敗。將在 ${delay / 1000} 秒後重試...`, error);
                            setTimeout(() => attempt(retryCount - 1, delay * 2), delay);
                        } else {
                            reject(error);
                        }
                    }
                };
                attempt(retries, backoff);
            });
        };

        const generateImageWithRetry = async (payload, apiKey, totalAttempts = 3) => {
            let lastError;
            for (let attempt = 1; attempt <= totalAttempts; attempt++) {
                try {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
                    // 注意：gemini-3-pro-image-preview 模型在 public API 尚未正式支援或需要特定權限，
                    // 這裡改為使用 gemini-2.0-flash-exp 作為預設的最新模型 endpoint，
                    // 或者您需要確認您的 API Key 是否有權限使用該特定模型。
                    // 若要生成圖片，通常會使用 imagen-3 或相關模型，
                    // 但因為此程式碼是使用 generateContent 且 payload 格式看起來像 Gemini 的，
                    // 我將保留您原本的邏輯，但請確保 endpoint 是正確的。
                    // 這裡先使用 gemini-2.0-flash-exp 以確保相容性，若有特定需求請自行更改。
                    // 修正：原代碼使用 gemini-3-pro-image-preview，假設這是使用者的目標模型。

                    const result = await fetchWithRetry(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    // 嘗試解析圖片資料
                    // Gemini 的圖片生成回應格式可能有所不同，這裡假設回應結構與原代碼預期一致
                    const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

                    // 如果沒有 inlineData，嘗試檢查是否有其它的圖片輸出格式 (例如 Imagen 的格式)
                    // 但為了保持原程式碼邏輯，這裡先不大幅修改解析邏輯

                    if (base64Data) return `data:image/png;base64,${base64Data}`;

                    // 如果沒有圖片數據，拋出錯誤
                    lastError = new Error("API 未返回圖片資料。回應內容: " + JSON.stringify(result));
                    console.warn(`第 ${attempt}/${totalAttempts} 次嘗試: ${lastError.message}`);
                } catch (error) {
                    lastError = error;
                    console.error(`第 ${attempt}/${totalAttempts} 次嘗試失敗:`, error);
                }
                if (attempt < totalAttempts) {
                    const delay = 2500 * Math.pow(2, attempt - 1);
                    await new Promise(res => setTimeout(res, delay));
                }
            }
            throw new Error(`圖片生成在 ${totalAttempts} 次嘗試後失敗。最後錯誤: ${lastError?.message || '未知錯誤'}`);
        };

        const removeBackground = (imageUrl) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const max = Math.max(r, g, b), min = Math.min(r, g, b);
                        const delta = max - min;
                        let hue = 0;
                        if (delta !== 0) {
                            if (max === g) hue = 60 * ((b - r) / delta + 2);
                            else if (max === r) hue = 60 * ((g - b) / delta + 4);
                            else hue = 60 * ((r - g) / delta);
                        }
                        if (hue < 0) hue += 360;
                        const saturation = max === 0 ? 0 : delta / max;
                        const value = max / 255;
                        const isGreenHue = (hue >= 60 && hue <= 180);
                        const isHighSaturation = saturation > 0.3;
                        const isBright = value > 0.4;
                        const isGreenDominant = (g > r + 30 && g > b + 30);
                        const pixelIndex = i / 4;
                        const x = pixelIndex % canvas.width;
                        const y = Math.floor(pixelIndex / canvas.width);
                        const isEdgePixel = (x < 15 || x > canvas.width - 15 || y < 15 || y > canvas.height - 15);
                        const isBackground = ((isGreenHue && isHighSaturation && isBright) || (isEdgePixel && isGreenDominant && g > 100) || (g > 200 && r < 50 && b < 50) || (Math.abs(r - 0) < 20 && Math.abs(g - 255) < 20 && Math.abs(b - 0) < 20));
                        if (isBackground) data[i + 3] = 0;
                    }
                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = () => reject(new Error('圖片載入失敗'));
                img.src = imageUrl;
            });
        };

        const getModelInstruction = (prompt, addText, isAnimeStyle) => {
            if (isAnimeStyle) {
                let instruction = `The highest priority is to maintain the exact facial features, likeness, and perceived gender of the person in the provided reference photo.
        Transform the person into a cute, expressive 1:1 aspect ratio chat sticker based on the following action: "${prompt.base}".
        The sticker MUST have a thick, clean white outline and a subtle drop shadow to make it pop.
        The sticker MUST have a solid, bright lime green background (RGB: 0, 255, 0) - this is crucial for background removal later.
        The final image should be a high-quality PNG.
        Do not alter the person's core facial structure.`;
                if (addText && prompt.memeText) {
                    instruction += `\nAdditionally, incorporate the text "${prompt.memeText}" into the sticker design in a bold, cute, and readable font that fits the anime style. The text should be easily visible.`;
                }
                return instruction;
            }
            let instruction = `The highest priority is to maintain the exact facial features, likeness, and perceived gender of the person in the provided reference photo.
        Create a photorealistic, expressive, high-detail 1:1 aspect ratio chat sticker of the person, captured with a professional camera aesthetic. The sticker should represent the following action or emotion: "${prompt.base}".
        The final image must look like a real photograph, not a cartoon or illustration.
        The sticker MUST have a thick, clean white outline and a subtle drop shadow to make it pop.
        The sticker MUST have a solid, bright lime green background (RGB: 0, 255, 0) - this is crucial for background removal later.
        The final image should be a high-quality, sharp-focus PNG.
        Do not alter the person's core facial structure or transform them into a 2D character.`;
            if (addText && prompt.memeText) {
                instruction += `\nAdditionally, incorporate the text "${prompt.memeText}" into the sticker design in a bold, clean, and readable font that complements the realistic photo style. The text should be easily visible against the bright lime green background.`;
            }
            return instruction;
        };

        const getInspirationPrompt = (lang) => {
            const prompts = {
                'zh-TW': "分析這張圖片中的人物、表情、服裝以及任何顯著的物體或背景。根據你所看到的，為貼圖包建議3個有創意、簡短且有趣的主題。例如，如果你看到一隻貓，建議'貓奴日常'。如果你看到穿西裝的人，建議'辦公室風雲'。請以一個簡單的JSON字串陣列格式返回你的答案，例如 `[\"主題一\", \"主題二\", \"主題三\"]`。只返回JSON陣列。",
                'zh-CN': "分析这张图片中的人物、表情、服装以及任何显著的物体或背景。根据你所看到的，为贴图包建议3个有创意、简短且有趣的主题。例如，如果你看到一只猫，建议'猫奴日常'。如果你看到穿西装的人，建议'办公室风云'。请以一个简单的JSON字符串数组格式返回你的答案，例如 `[\"主题一\", \"主题二\", \"主题三\"]`。只返回JSON数组。",
                'en': "Analyze the person, their expression, clothing, and any notable objects or background in this image. Suggest 3 creative, short, and fun themes for a sticker pack based on what you see. For example, if you see a cat, suggest 'Cat Lover Life'. If you see someone in a suit, suggest 'Office Drama'. Return your answer as a simple JSON array of strings, like `[\"Theme One\", \"Theme Two\", \"Theme Three\"]`. Only return the JSON array.",
                'ja': "この画像の中の人物、表情、服装、そして目立つ物や背景を分析してください。見たものに基づいて、ステッカーパックのための創造的で短く、楽しいテーマを3つ提案してください。例えば、猫を見たら「猫好きの日常」、スーツを着た人を見たら「オフィスドラマ」などを提案してください。答えは `[\"テーマ1\", \"テーマ2\", \"テーマ3\"]` のような単純なJSON文字列配列として返してください。JSON配列のみを返してください。",
                'ko': "이 이미지의 인물, 표정, 의상 및 눈에 띄는 물체나 배경을 분석하십시오. 본 것을 바탕으로 스티커 팩에 대한 창의적이고 짧고 재미있는 테마 3가지를 제안하십시오. 예를 들어, 고양이를 보면 '고양이 집사의 일상'을 제안하고, 정장을 입은 사람을 보면 '오피스 드라마'를 제안하십시오. 답은 `[\"테마 1\", \"테마 2\", \"테마 3\"]`과 같은 간단한 JSON 문자열 배열로 반환하십시오. JSON 배열만 반환하십시오。"
            };
            return prompts[lang] || prompts['en']; // Default to English
        };

        const getGenerateIdeasSystemPrompt = (lang, numIdeas) => {
            const langInstructions = {
                'zh-TW': "一個簡短的、描述性的繁體中文 `id`（例如，'喝咖啡'，'打電動'）。這將是面向用戶的名稱。",
                'zh-CN': "一个简短的、描述性的简体中文 `id`（例如，'喝咖啡'，'打电动'）。这将是面向用户的名称。",
                'en': "A short, descriptive `id` in English (e.g., 'Drinking Coffee', 'Gaming'). This will be the user-facing name.",
                'ja': "短く説明的な日本語の `id`（例：「コーヒーを飲む」、「ゲーム中」）。これがユーザー向けの名称になります。",
                'ko': "짧고 설명적인 한국어 `id` (예: '커피 마시기', '게임하기'). 이것이 사용자에게 표시될 이름입니다。"
            };

            const memeTextInstructions = {
                'zh-TW': "A short, catchy \`memeText\` in Traditional Chinese (e.g., '好喔!', '衝鴨!', '????').",
                'zh-CN': "A short, catchy \`memeText\` in Simplified Chinese (e.g., '好耶!', '冲鸭!', '????').",
                'en': "A short, catchy \`memeText\` in English (e.g., 'COFFEE!', 'GAME ON', 'LOL').",
                'ja': "A short, catchy \`memeText\` in Japanese (e.g., 'やった!', '了解', 'www').",
                'ko': "A short, catchy \`memeText\` in Korean (e.g., '대박!', '화이팅', 'ㅋㅋ')."
            };

            return `You are a creative assistant that generates fun and expressive chat sticker ideas. Based on the user's description, provide a list of ${numIdeas} sticker ideas. Each idea MUST include:
        1. ${langInstructions[lang] || langInstructions['en']}
        2. A detailed \`base\` prompt in English for an image generation model (e.g., 'happily sipping a large mug of coffee, looking energized').
        3. ${memeTextInstructions[lang] || memeTextInstructions['en']}

        Your response MUST be a valid JSON array of objects, following this exact schema. Do not include any other text or markdown formatting.`;
        };


        // --- 圖示 ---
        const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-10 h-10"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /></svg>;
        const IconSparkles = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.894 20.567 16.5 21.75l-.394-1.183a2.25 2.25 0 0 0-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 0 0 1.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 0 0 1.423 1.423l1.183.394-1.183.394a2.25 2.25 0 0 0-1.423 1.423Z" /></svg>;
        const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>;
        const IconCamera = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 0 0-1.134-.175 2.31 2.31 0 0 1-1.64-1.055l-.822-1.316a2.192 2.192 0 0 0-1.736-1.039 48.776 48.776 0 0 0-5.232 0 2.192 2.192 0 0 0-1.736 1.039l-.821 1.316Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M16.5 12.75a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0ZM18.75 10.5h.008v.008h-.008V10.5Z" /></svg>;
        const IconZip = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" /></svg>;
        const IconGlobe = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M12 21a9.004 9.004 0 008.716-6.747M12 21a9.004 9.004 0 01-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 017.843 4.582M12 3a8.997 8.997 0 00-7.843 4.582m15.686 0A11.953 11.953 0 0112 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0121 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919 0 0112 16.5c-3.162 0-6.133-.815-8.716-2.247m0 0A9.015 9.015 0 013 12c0-1.605.42-3.113 1.157-4.418" /></svg>;
        const IconHistory = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /></svg>;
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5"><path strokeLinecap="round" strokeLinejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.134-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.067-2.09.921-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg>;
        const IconUploadToStore = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3 3m3-3l3 3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.233-2.33 3 3 0 013.758 3.848A3.752 3.752 0 0118 19.5H6.75z" /></svg>;
        const IconImport = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M9 8.25H7.5a2.25 2.25 0 0 0-2.25 2.25v9a2.25 2.25 0 0 0 2.25 2.25h9A2.25 2.25 0 0 0 18.75 19.5v-9a2.25 2.25 0 0 0-2.25-2.25H15M9 12l3 3m0 0l3-3m-3 3V2.25" /></svg>;
        const IconExport = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /></svg>;
        const IconKey = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M15.75 5.25a3 3 0 0 1 3 3m3 0a6 6 0 0 1-7.029 5.912c-.563-.097-1.159.026-1.563.43L10.5 17.25H8.25v2.25H6v2.25H2.25v-2.818c0-.597.237-1.17.659-1.591l6.499-6.499c.404-.404.527-1 .43-1.563A6 6 0 1 1 21.75 8.25Z" /></svg>;

        // --- React 元件 ---

        const Button = ({ children, onClick, disabled, primary = false, secondary = false, className = '' }) => {
            // 星宇風格按鈕 (StarLux Style)
            // 預設 (Default): 深曜石灰背景 + 金色邊框
            const baseClass = "px-6 py-2.5 rounded-lg font-semibold tracking-wider transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg hover:shadow-xl transform hover:-translate-y-0.5 border";

            let themeClass = "bg-[#2A2A2A] border-[#666] text-[#CCC] hover:bg-[#333] hover:text-[#BFA37C] hover:border-[#BFA37C]"; // Default

            if (primary) {
                // 主按鈕：玫瑰金/大地金漸層 (Rose Gold / Earth Gold) - 模擬機身腰線或貴賓室色調
                themeClass = "text-[#2A1E11] border-[#BFA37C] bg-gradient-to-r from-[#C6A678] to-[#9D7E50] hover:from-[#D4B384] hover:to-[#AB8C5D] shadow-[#9D7E50]/20";
            }
            if (secondary) {
                // 次要按鈕：Polaris Green (深墨綠/橄欖綠) - 呼應制服與品牌識別色
                themeClass = "text-[#E0E0E0] border-[#4A5D4F] bg-gradient-to-r from-[#3C4A3E] to-[#2F3E35] hover:from-[#4A5D4F] hover:to-[#3C4A3E] shadow-[#2F3E35]/30";
            }

            return <button onClick={onClick} disabled={disabled} className={`${baseClass} ${themeClass} ${className}`}>{children}</button>;
        };

        const ToggleSwitch = ({ id, checked, onChange, label }) => (
            <div className="flex items-center">
                <label htmlFor={id} className="flex items-center cursor-pointer">
                    <div className="relative">
                        <input id={id} type="checkbox" className="sr-only" checked={checked} onChange={onChange} />
                        {/* 開關背景色: 啟動時為大地金 */}
                        <div className={`block w-14 h-8 rounded-full transition-colors border border-gray-600 ${checked ? 'bg-[#9D7E50] border-[#BFA37C]' : 'bg-[#1F1F1F]'}`}></div>
                        <div className={`dot absolute left-1 top-1 bg-[#E0E0E0] w-6 h-6 rounded-full transition-transform duration-300 ease-in-out shadow-md ${checked ? 'transform translate-x-6 bg-white' : ''}`}></div>
                    </div>
                    <div className="ml-3 text-[#CCC] select-none font-medium tracking-wide">{label}</div>
                </label>
            </div>
        );

        const StickerDisplay = ({ emotion, imageUrl, onDownload, onRegenerate, isProcessed = false }) => (
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} whileHover={{ y: -5 }} className="relative group p-3 bg-[#222]/80 rounded-xl shadow-lg transition-all duration-300 hover:shadow-[#BFA37C]/10 border border-[#444] hover:border-[#BFA37C]/50 backdrop-blur-sm">
                <div className="aspect-square bg-grid-pattern flex items-center justify-center rounded-lg relative overflow-hidden bg-[#1a1a1a]">
                    <img src={imageUrl} alt={`Sticker for ${emotion}`} className="w-full h-full object-contain" />
                    {isProcessed && <div className="absolute top-2 left-2 bg-[#3C4A3E] text-[#BFA37C] border border-[#BFA37C] text-xs px-2 py-1 rounded font-semibold shadow-lg">透明背景</div>}
                </div>
                <p className="text-center mt-3 text-lg font-medium text-[#CCC] px-1 truncate group-hover:text-[#BFA37C] transition-colors">{emotion}</p>
                <div className="absolute top-3 right-3 z-10 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2">
                    <button onClick={onRegenerate} className="p-2 rounded-full bg-black/70 text-[#BFA37C] border border-[#BFA37C]/30 hover:bg-black/90 hover:border-[#BFA37C] transition-all backdrop-blur-sm shadow-lg" aria-label="Regenerate sticker"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5"><path strokeLinecap="round" strokeLinejoin="round" d="M16.023 16.023A7.5 7.5 0 1 0 8.25 8.25V6.75a.75.75 0 0 1 1.5 0v3.75a.75.75 0 0 1-.75.75H5.25a.75.75 0 0 1 0-1.5h2.37a5.98 5.98 0 0 1 8.403 8.403Z" /></svg></button>
                    <button onClick={() => onDownload(imageUrl, emotion)} className="p-2 rounded-full bg-black/70 text-[#BFA37C] border border-[#BFA37C]/30 hover:bg-black/90 hover:border-[#BFA37C] transition-all backdrop-blur-sm shadow-lg" aria-label="Download sticker"><IconDownload /></button>
                </div>
            </motion.div>
        );

        const SkeletonLoader = ({ className }) => <div className={`animate-pulse bg-[#333] ${className}`}></div>;

        const LoadingCard = ({ emotion }) => (
            <div className="p-3 bg-[#222]/80 rounded-xl shadow-md border border-[#444]">
                <div className="aspect-square bg-grid-pattern rounded-lg relative flex items-center justify-center bg-[#1a1a1a]"><div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-[#BFA37C]"></div></div>
                <div className="mt-3 flex justify-center"><SkeletonLoader className="h-5 w-1/2 rounded-md" /></div>
            </div>
        );

        const ErrorCard = ({ emotion, onRegenerate }) => (
            <div className="p-3 bg-red-900/10 rounded-xl shadow-md border border-red-500/20">
                <div className="aspect-square bg-grid-pattern rounded-lg flex flex-col items-center justify-center text-center p-4 border-2 border-dashed border-red-500/30">
                    <p className="text-red-400 font-medium mb-4">生成失敗</p>
                    {onRegenerate && <Button onClick={onRegenerate} primary>重試</Button>}
                </div>
                <p className="text-center mt-3 text-lg font-semibold text-gray-400 px-1 truncate">{emotion}</p>
            </div>
        );

        const ErrorNotification = ({ message, onDismiss }) => {
            if (!message) return null;
            return (
                <div className="fixed top-5 left-1/2 z-[100] w-full max-w-md p-4 bg-[#2A1E11] border border-red-800 text-red-200 rounded-lg shadow-2xl flex items-center justify-between animate-fade-in-down" style={{ transform: 'translateX(-50%)' }}>
                    <span>{message}</span>
                    <button onClick={onDismiss} className="p-1 rounded-full hover:bg-white/10 transition-colors ml-4"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-400"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
                </div>
            );
        };

        const ApiKeyModal = ({ t, isOpen, onClose, onSave, currentKey }) => {
            const [inputKey, setInputKey] = useState(currentKey);

            useEffect(() => {
                setInputKey(currentKey);
            }, [currentKey, isOpen]);

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/90 z-[60] flex items-center justify-center p-4" onClick={onClose}>
                    <motion.div
                        initial={{ opacity: 0, scale: 0.95 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.95 }}
                        className="bg-[#1E1E1E] rounded-2xl p-6 border border-[#BFA37C]/30 shadow-2xl w-full max-w-md relative"
                        onClick={e => e.stopPropagation()}
                    >
                        <h3 className="text-2xl font-semibold mb-4 text-[#BFA37C] tracking-wide">{t('api_key_modal_title')}</h3>
                        <p className="text-gray-400 mb-4 text-sm">{t('api_key_description')}</p>

                        <input
                            type="text"
                            value={inputKey}
                            onChange={(e) => setInputKey(e.target.value)}
                            placeholder={t('api_key_input_placeholder')}
                            className="w-full bg-[#111] border border-[#444] rounded-lg py-3 px-4 focus:outline-none focus:ring-1 focus:ring-[#BFA37C] text-[#E0E0E0] text-sm mb-4 placeholder-gray-600"
                        />

                        <div className="flex flex-col gap-3">
                            <Button onClick={() => { onSave(inputKey); onClose(); }} primary className="w-full">
                                {t('api_key_save_btn')}
                            </Button>
                            <a
                                href="https://aistudio.google.com/api-keys"
                                target="_blank"
                                rel="noopener noreferrer"
                                className="w-full"
                            >
                                <Button className="w-full flex items-center justify-center gap-2">
                                    {t('api_key_get_btn')} <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4"><path strokeLinecap="round" strokeLinejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25" /></svg>
                                </Button>
                            </a>
                        </div>

                        <button onClick={onClose} className="absolute top-4 right-4 p-2 rounded-full text-gray-500 hover:text-[#BFA37C] transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
                        </button>
                    </motion.div>
                </div>
            );
        };

        const CameraModal = ({ isOpen, onClose, onCapture }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const streamRef = useRef(null);
            const [capturedImage, setCapturedImage] = useState(null);
            const [cameraError, setCameraError] = useState(null);
            const stopCamera = useCallback(() => { if (streamRef.current) { streamRef.current.getTracks().forEach(track => track.stop()); streamRef.current = null; } if (videoRef.current) videoRef.current.srcObject = null; }, []);
            const startCamera = useCallback(async () => { if (videoRef.current) { setCameraError(null); try { stopCamera(); const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 1024 }, height: { ideal: 1024 }, facingMode: 'user' } }); videoRef.current.srcObject = stream; streamRef.current = stream; } catch (err) { setCameraError("相機存取被拒絕。請在您的瀏覽器設定中允許相機存取。"); } } }, [stopCamera]);
            useEffect(() => { if (isOpen && !capturedImage) startCamera(); else stopCamera(); return stopCamera; }, [isOpen, capturedImage, startCamera, stopCamera]);
            const handleCapture = () => { if (videoRef.current && canvasRef.current) { const video = videoRef.current, canvas = canvasRef.current; canvas.width = video.videoWidth; canvas.height = video.videoHeight; const context = canvas.getContext('2d'); context.scale(-1, 1); context.drawImage(video, -canvas.width, 0, canvas.width, canvas.height); setCapturedImage(canvas.toDataURL('image/png')); } };
            const handleConfirm = () => { if (capturedImage) { onCapture(capturedImage); onClose(); } };
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black/90 z-50 flex items-center justify-center p-4">
                    <motion.div initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} transition={{ duration: 0.2 }} className="bg-[#1E1E1E] rounded-2xl p-6 border border-[#BFA37C]/30 shadow-2xl w-full max-w-2xl text-center relative">
                        <h3 className="text-2xl font-semibold mb-4 text-[#BFA37C]">相機</h3>
                        <div className="aspect-square bg-black rounded-lg overflow-hidden relative mb-4 flex items-center justify-center border border-[#333]">{cameraError ? <div className="p-4 text-red-400">{cameraError}</div> : <>{capturedImage ? <img src={capturedImage} alt="拍攝預覽" className="w-full h-full object-cover" /> : <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover transform -scale-x-100"></video>}</>}</div>
                        <div className="flex justify-center gap-4">{capturedImage ? <><Button onClick={() => setCapturedImage(null)}>重拍</Button><Button onClick={handleConfirm} primary>使用照片</Button></> : <button onClick={handleCapture} disabled={!!cameraError} className="w-20 h-20 rounded-full bg-white/10 border-4 border-[#BFA37C]/50 focus:outline-none focus:ring-4 focus:ring-[#BFA37C]/30 transition-all hover:border-[#BFA37C] hover:bg-white/20 disabled:opacity-50 disabled:cursor-not-allowed"></button>}</div>
                        <button onClick={onClose} className="absolute top-4 right-4 p-2 rounded-full text-gray-500 hover:text-[#BFA37C] transition-colors"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18 18 6M6 6l12 12" /></svg></button>
                        <canvas ref={canvasRef} className="hidden"></canvas>
                    </motion.div>
                </div>
            );
        };



        const AppFooter = ({ currentVersion }) => {
            return (
                <footer className="mt-20 mb-8 border-t border-[#333] pt-12">
                    <div className="text-center flex flex-col items-center justify-center gap-6">
                        {/* External buttons removed as per request */}
                    </div>
                    <p className="text-center text-gray-600 mt-12 text-sm">{currentVersion}</p>
                    <p className="text-center text-gray-500 mt-2 text-sm whitespace-nowrap"></p>
                </footer>
            );
        };

        const HistoryPanel = ({ t, isOpen, onClose, history, onLoadSession, onDeleteSession, onExportHistory, onImportHistory }) => {
            const [versionLog, setVersionLog] = useState([]);
            const [isLoadingLog, setIsLoadingLog] = useState(true);

            useEffect(() => {
                if (isOpen) {
                    setIsLoadingLog(true);
                    fetch('https://callmygod.com/api/VersionLog_OCS.php')
                        .then(res => res.json())
                        .then(data => setVersionLog(data))
                        .catch(err => console.error("Failed to fetch version log:", err))
                        .finally(() => setIsLoadingLog(false));
                }
            }, [isOpen]);

            return (
                <AnimatePresence>
                    {isOpen && (
                        <div className="fixed inset-0 z-40 flex">
                            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} className="fixed inset-0 bg-black/70 backdrop-blur-sm" onClick={onClose} />
                            <motion.div initial={{ x: '-100%' }} animate={{ x: 0 }} exit={{ x: '-100%' }} transition={{ type: 'spring', stiffness: 300, damping: 30 }} className="relative w-full max-w-sm sm:max-w-md bg-[#181818] border-r border-[#333] shadow-2xl flex flex-col h-full">
                                <header className="flex items-center justify-between p-4 border-b border-[#333] flex-shrink-0">
                                    <h2 className="text-xl font-semibold text-[#BFA37C] tracking-wide">{t('history_title')}</h2>
                                    <div className="flex items-center gap-2">
                                        <button onClick={onImportHistory} title={t('history_import')} className="p-2 rounded-full text-gray-400 hover:bg-white/5 hover:text-[#BFA37C] transition-colors">
                                            <IconImport />
                                        </button>
                                        <button onClick={onExportHistory} title={t('history_export')} className="p-2 rounded-full text-gray-400 hover:bg-white/5 hover:text-[#BFA37C] transition-colors">
                                            <IconExport />
                                        </button>
                                        <button onClick={onClose} className="p-2 rounded-full text-gray-400 hover:bg-white/5 hover:text-white transition-colors">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
                                        </button>
                                    </div>
                                </header>

                                <div className="h-2/3 overflow-y-auto p-4 custom-scrollbar">
                                    {history.length === 0 ? (
                                        <div className="text-center text-gray-500 h-full flex flex-col items-center justify-center">
                                            <IconHistory />
                                            <p className="mt-4">{t('history_empty')}</p>
                                        </div>
                                    ) : (
                                        <ul className="space-y-3">
                                            {history.map(session => (
                                                <li key={session.id} className="bg-[#222] p-3 rounded-lg border border-[#333] hover:border-[#BFA37C]/50 transition-colors group">
                                                    <div className="flex items-center gap-4">
                                                        <img src={session.uploadedImage} alt="Uploaded thumbnail" className="w-16 h-16 object-cover rounded-md flex-shrink-0 border border-[#444]" />
                                                        <div className="flex-grow overflow-hidden">
                                                            <p className="text-sm font-medium text-[#CCC]">
                                                                {new Date(session.timestamp).toLocaleString(undefined, { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}
                                                            </p>
                                                            <p className="text-xs text-gray-500">{session.generatedImages.length} 個貼圖</p>
                                                        </div>
                                                        <button onClick={() => { if (window.confirm(t('history_delete_confirm'))) onDeleteSession(session.id) }} className="p-2 text-gray-500 hover:text-red-400 transition-colors opacity-0 group-hover:opacity-100"><IconTrash /></button>
                                                    </div>
                                                    <button onClick={() => onLoadSession(session)} className="w-full mt-3 text-center bg-[#2F3E35] hover:bg-[#3C4A3E] text-[#BFA37C] border border-[#4A5D4F] text-sm font-semibold py-1.5 rounded-md transition-colors">{t('history_load_session')}</button>
                                                </li>
                                            ))}
                                        </ul>
                                    )}
                                </div>

                                <div className="flex-shrink-0 border-t border-[#333] mx-4"></div>

                                <div className="h-1/3 p-4 flex flex-col">
                                    <h3 className="text-lg font-semibold text-[#CCC] mb-3 flex-shrink-0">{t('version_log_title')}</h3>
                                    <div className="overflow-y-auto custom-scrollbar">
                                        {isLoadingLog ? <div className="text-gray-500">讀取中...</div> : (
                                            <ul className="space-y-4 text-sm">
                                                {versionLog.map(log => (
                                                    <li key={log.date + log.title} className="border-l-2 border-[#BFA37C] pl-3">
                                                        <p className="font-semibold text-[#E0E0E0]">{log.title} <span className="text-xs text-[#888] ml-2 font-normal">{log.date}</span></p>
                                                        <p className="text-[#999] whitespace-pre-wrap">{log.content}</p>
                                                    </li>
                                                ))}
                                            </ul>
                                        )}
                                    </div>
                                </div>
                            </motion.div>
                        </div>
                    )}
                </AnimatePresence>
            );
        };



        const VersionCheckModal = ({ t, info, onClose }) => {
            if (!info) return null;

            const handleRedirect = () => {
                window.open(info.url, '_blank', 'noopener,noreferrer');
            };

            return (
                <div className="fixed inset-0 bg-black/80 z-[100] flex items-center justify-center p-4">
                    <motion.div
                        initial={{ opacity: 0, scale: 0.9 }}
                        animate={{ opacity: 1, scale: 1 }}
                        className="bg-[#1E1E1E] backdrop-blur-md border border-[#BFA37C] rounded-2xl p-6 w-full max-w-sm text-center shadow-[0_0_30px_rgba(191,163,124,0.1)]">
                        <h3 className="text-xl font-bold mb-2 text-[#BFA37C]">{t('version_title')}</h3>
                        <p className="text-gray-300 mb-6" dangerouslySetInnerHTML={{ __html: t('version_message').replace('{version}', `<span class="font-bold text-white">${info.version}</span>`) }} />
                        <div className="flex flex-col gap-3">
                            <button onClick={handleRedirect} className="w-full text-center p-3 font-semibold text-[#2A1E11] bg-gradient-to-r from-[#C6A678] to-[#9D7E50] hover:from-[#D4B384] hover:to-[#AB8C5D] rounded-lg transition-colors">
                                {t('version_update_btn')}
                            </button>
                            <button onClick={onClose} className="w-full text-center p-3 text-gray-400 bg-[#2A2A2A] hover:text-[#BFA37C] rounded-lg transition-colors">
                                {t('version_old_btn')}
                            </button>
                        </div>
                    </motion.div>
                </div>
            );
        };


        const App = () => {
            // 簡化: 移除語言狀態，直接使用中文翻譯
            // const [language, setLanguage] = useState('zh-TW'); <- Removed
            const [appReady, setAppReady] = useState(false);

            const t = useCallback((key) => {
                return translations[key] || key;
            }, []);

            const [uploadedImage, setUploadedImage] = useState(null);
            const [generatedImages, setGeneratedImages] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const fileInputRef = useRef(null);
            const importFileRef = useRef(null);
            const [isUploading, setIsUploading] = useState(false);
            const [isCameraOpen, setIsCameraOpen] = useState(false);
            const resultsRef = useRef(null);
            const [isRemovingBackground, setIsRemovingBackground] = useState(false);
            const [removeBgProgress, setRemoveBgProgress] = useState(0);
            const [processedImages, setProcessedImages] = useState([]);
            const [selectedStickers, setSelectedStickers] = useState([]);
            const [isAnimeStyle, setIsAnimeStyle] = useState(false);
            const [addText, setAddText] = useState(true);
            const [isZipping, setIsZipping] = useState(false);
            const [customIdeaInput, setCustomIdeaInput] = useState('');
            const [customStickerPack, setCustomStickerPack] = useState([]);
            const [isGeneratingIdeas, setIsGeneratingIdeas] = useState(false);
            const [suggestedThemes, setSuggestedThemes] = useState([]);
            const [isSuggestingThemes, setIsSuggestingThemes] = useState(false);
            const [numIdeasToGenerate, setNumIdeasToGenerate] = useState(8);
            const [history, setHistory] = useState([]);
            const [isHistoryPanelOpen, setIsHistoryPanelOpen] = useState(false);

            // Links state removed
            const [versionMismatchInfo, setVersionMismatchInfo] = useState(null);

            // API Key State
            const [userApiKey, setUserApiKey] = useState('');
            const [isApiKeyModalOpen, setIsApiKeyModalOpen] = useState(false);

            const CURRENT_VERSION = 'V3.8.0';
            const APP_ID = '102';


            const defaultStickerPack = useMemo(() => ({
                prompts: [
                    { id: 'sticker_happy', base: 'a happy, joyful, smiling expression, maybe with stars in the eyes', memeText: 'YAY!' },
                    { id: 'sticker_sad', base: 'a sad expression, with cartoonishly large tears streaming down the face', memeText: 'SO SAD' },
                    { id: 'sticker_laugh', base: 'laughing out loud hysterically, eyes squeezed shut', memeText: 'LOL' },
                    { id: 'sticker_angry', base: 'an angry, fuming expression with red cheeks and steam coming out of the ears', memeText: 'GRRR' },
                    { id: 'sticker_love', base: 'an adoring expression with large heart-shaped eyes', memeText: 'UWU' },
                    { id: 'sticker_ok', base: 'giving a cheerful thumbs-up sign', memeText: 'OK!' },
                    { id: 'sticker_confused', base: 'a confused expression with question marks floating around the head', memeText: '???' },
                    { id: 'sticker_sleepy', base: 'a very sleepy, yawning expression with a snot bubble', memeText: 'Zzz...' },
                    { id: 'sticker_surprised', base: 'a shocked, surprised expression with wide eyes and open mouth, like "wow"', memeText: 'WOW!' },
                    { id: 'sticker_thinking', base: 'a thoughtful expression with a finger on the chin, looking upwards', memeText: 'Hmm...' },
                    { id: 'sticker_crying', base: 'a crying expression with a quivering lip, feeling wronged', memeText: 'SNIFF...' },
                    { id: 'sticker_pleading', base: 'a pleading expression with big, shimmering "puppy dog" eyes', memeText: 'Pls?' },
                ]
            }), []);

            const activeStickerPack = customStickerPack.length > 0 ? customStickerPack : defaultStickerPack.prompts;

            // --- 初始化和語言偵測 ---
            useEffect(() => {
                // Language Detection Removed
                // ...

                // API Key loading
                const storedApiKey = localStorage.getItem('ocs_api_key');
                if (storedApiKey) setUserApiKey(storedApiKey);

                // ZIP Library
                // No need to inject script manually, already in head

                // DB Init and API calls
                const initializeApp = async () => {
                    try {
                        await initDB();
                        // External links fetching removed as per request

                        // Secondary API call
                        fetch('https://callmygod.com/api/game_check.php?game=102').catch(error => console.error('Secondary API call failed:', error));

                    } catch (error) {
                        console.error("Initialization failed:", error);
                    } finally {
                        setAppReady(true);
                    }
                };

                initializeApp();

                setSelectedStickers(defaultStickerPack.prompts.map(p => p.id));

            }, [defaultStickerPack]);

            // Load history once app is ready and language is set
            useEffect(() => {
                if (appReady) {
                    loadHistoryFromDB().then(setHistory).catch(() => setError(t('error_db_load')));
                }
            }, [appReady, t]);


            const handleStickerSelection = (stickerId) => setSelectedStickers(prev => prev.includes(stickerId) ? prev.filter(id => id !== stickerId) : [...prev, stickerId]);

            const handleSaveApiKey = (key) => {
                setUserApiKey(key);
                localStorage.setItem('ocs_api_key', key);
            };

            const regenerateImageAtIndex = async (imageIndex) => {
                if (!userApiKey) { setError(t('error_api_key_missing')); setIsApiKeyModalOpen(true); return; }
                const imageToRegenerate = generatedImages[imageIndex];
                if (!imageToRegenerate) return;
                setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'pending' } : img));
                setError(null);
                const originalPrompts = activeStickerPack.filter(p => generatedImages.map(gi => gi.id).includes(p.id));
                const prompt = originalPrompts[imageIndex];
                if (!prompt) { setError(t('error_no_prompt_found')); setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'failed' } : img)); return; }
                try {
                    const imageWithoutPrefix = uploadedImage.split(',')[1];
                    const modelInstruction = getModelInstruction(prompt, addText, isAnimeStyle);
                    const payload = { contents: [{ parts: [{ text: modelInstruction }, { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }] }] };
                    const imageUrl = await generateImageWithRetry(payload, userApiKey);
                    setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'success', imageUrl } : img));
                } catch (err) {
                    setError(t('error_regenerate_failed').replace('{stickerName}', t(prompt.id)));
                    setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'failed' } : img));
                }
            };

            const handleImageUpload = async (event) => {
                const file = event.target.files[0];
                if (file) {
                    setIsUploading(true);
                    setError(null);
                    try {
                        const base64Image = await toBase64(file);
                        const croppedImage = await cropImageToSquare(base64Image);
                        setUploadedImage(croppedImage);
                        setGeneratedImages([]);
                        setSuggestedThemes([]);
                    } catch (err) { setError(t('error_file_process')); }
                    finally { setIsUploading(false); }
                }
            };

            const handleCaptureConfirm = async (imageDataUrl) => {
                try {
                    const croppedImage = await cropImageToSquare(imageDataUrl);
                    setUploadedImage(croppedImage);
                    setGeneratedImages([]);
                    setError(null);
                    setSuggestedThemes([]);
                } catch (err) {
                    setError(t('error_file_process'));
                }
            };

            const handleGenerateClick = async () => {
                if (!userApiKey) { setError(t('error_api_key_missing')); setIsApiKeyModalOpen(true); return; }
                if (!uploadedImage) { setError(t('error_upload')); return; }
                if (selectedStickers.length === 0) { setError(t('error_select_one')); return; }
                setIsLoading(true); setError(null); setGeneratedImages([]);
                setTimeout(() => { resultsRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 100);
                const imageWithoutPrefix = uploadedImage.split(',')[1];
                const promptsForGeneration = activeStickerPack.filter(p => selectedStickers.includes(p.id));
                setGeneratedImages(promptsForGeneration.map(p => ({ id: p.id, status: 'pending', imageUrl: null })));

                let successfulGenerations = [];
                for (let i = 0; i < promptsForGeneration.length; i++) {
                    const p = promptsForGeneration[i];
                    const promptData = activeStickerPack.find(item => item.id === p.id);
                    if (!promptData) continue;

                    try {
                        const modelInstruction = getModelInstruction(promptData, addText, isAnimeStyle);
                        const payload = { contents: [{ parts: [{ text: modelInstruction }, { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }] }] };
                        const imageUrl = await generateImageWithRetry(payload, userApiKey);
                        const successResult = { id: p.id, status: 'success', imageUrl };
                        successfulGenerations.push(successResult);
                        setGeneratedImages(prev => prev.map(img => img.id === p.id ? successResult : img));
                    } catch (err) {
                        setGeneratedImages(prev => prev.map(img => img.id === p.id ? { ...img, status: 'failed' } : img));
                    }
                }

                if (successfulGenerations.length > 0) {
                    const session = {
                        timestamp: new Date().toISOString(),
                        uploadedImage,
                        generatedImages: successfulGenerations,
                        settings: { isAnimeStyle, addText, activeStickerPack }
                    };
                    saveSessionToDB(session).then((id) => {
                        setHistory(prev => [{ ...session, id }, ...prev]);
                    }).catch(() => setError(t('error_db_save')));
                }
                setIsLoading(false);
            };

            const triggerDownload = (href, fileName) => { const link = document.createElement('a'); link.href = href; link.download = fileName; document.body.appendChild(link); link.click(); document.body.removeChild(link); };
            const handleDownloadRequest = (imageUrl, emotionId, isProcessed = false) => { const suffix = isProcessed ? '-transparent' : ''; const fileName = `sticker-${emotionId.toLowerCase().replace(/\s+/g, '-')}${suffix}.png`; triggerDownload(imageUrl, fileName); };

            const handleDownloadAllAsZip = async () => {
                if (isZipping || typeof window.JSZip === 'undefined') { if (typeof window.JSZip === 'undefined') setError(t('error_zip_lib')); return; }
                setIsZipping(true); setError(null);
                try {
                    const zip = new window.JSZip();
                    const imagesToPack = processedImages.length > 0 ? processedImages : generatedImages.filter(img => img.status === 'success');
                    if (imagesToPack.length === 0) { setError(t('error_no_stickers_to_zip')); return; }
                    await Promise.all(imagesToPack.map(async (img) => {
                        const imageUrl = img.processedImageUrl || img.imageUrl;
                        const response = await fetch(imageUrl); const blob = await response.blob();
                        const suffix = img.isProcessed ? '-transparent' : ''; const fileName = `sticker-${img.id.toLowerCase().replace(/\s+/g, '-')}${suffix}.png`;
                        zip.file(fileName, blob);
                    }));
                    const content = await zip.generateAsync({ type: "blob" });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(content);
                    link.download = processedImages.length > 0 ? "ai-sticker-pack-transparent.zip" : "ai-sticker-pack.zip";
                    document.body.appendChild(link); link.click(); document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                } catch (err) { setError(t('error_zip_failed')); }
                finally { setIsZipping(false); }
            };

            const handleStartOver = () => { setGeneratedImages([]); setUploadedImage(null); setError(null); setCustomStickerPack([]); setCustomIdeaInput(''); setSuggestedThemes([]); setSelectedStickers(defaultStickerPack.prompts.map(p => p.id)); setProcessedImages([]); setRemoveBgProgress(0); window.scrollTo({ top: 0, behavior: 'smooth' }); };

            const handleRemoveBackground = async () => {
                const successfulImages = generatedImages.filter(img => img.status === 'success');
                if (successfulImages.length === 0) { setError(t('error_no_stickers_to_process')); return; }
                setIsRemovingBackground(true); setRemoveBgProgress(0); setError(null); setProcessedImages([]);
                try {
                    const processedResults = [];
                    for (let i = 0; i < successfulImages.length; i++) {
                        const img = successfulImages[i];
                        try {
                            processedResults.push({ ...img, processedImageUrl: await removeBackground(img.imageUrl), isProcessed: true });
                        } catch (err) { processedResults.push({ ...img, processedImageUrl: img.imageUrl, isProcessed: false }); }
                        setRemoveBgProgress(((i + 1) / successfulImages.length) * 100);
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    setProcessedImages(processedResults);
                } catch (err) { setError(t('error_bg_remove_failed')); }
                finally { setIsRemovingBackground(false); }
            };

            const handleGenerateIdeas = async () => {
                if (!customIdeaInput.trim()) { setError(t('error_ideas_input')); return; }
                setIsGeneratingIdeas(true); setError(null); setCustomStickerPack([]); setSuggestedThemes([]);

                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
                const textPrompt = `Use "Traditional Chinese" to suggest 8 diverse...`; // 確保 Prompt 也是中文或這部分不需要改因為 t() 會處理? 
                // getGenerateIdeasSystemPrompt 函式需要改，因為它可能使用了 language 參數
                // 檢查 getGenerateIdeasSystemPrompt 的實作... 它在上面某處。
                // 為了安全起見，我這一步先不改 prompt 生成邏輯，只改 t() 和 state。
                // 稍後我會檢查 getGenerateIdeasSystemPrompt 和 getInspirationPrompt。
                // 這裡的 language 變數已經移除了，所以需要修正呼叫。
                const systemPrompt = getGenerateIdeasSystemPrompt('zh-TW', numIdeasToGenerate);
                const payload = { contents: [{ parts: [{ text: customIdeaInput }] }], systemInstruction: { parts: [{ text: systemPrompt }] }, generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "OBJECT", properties: { "id": { "type": "STRING" }, "base": { "type": "STRING" }, "memeText": { "type": "STRING" } }, required: ["id", "base", "memeText"] } } } };
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                    const result = await response.json(); const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (jsonText) { const ideas = JSON.parse(jsonText); setCustomStickerPack(ideas); setSelectedStickers(ideas.map(idea => idea.id)); } else throw new Error("API did not return valid JSON content.");
                } catch (err) { setError(t('error_ideas_failed') + " (" + err.message + ")"); }
                finally { setIsGeneratingIdeas(false); }
            };

            const handleGetInspirationFromImage = async () => {
                if (!uploadedImage) { setError(t('error_upload')); return; }
                setIsSuggestingThemes(true); setError(null); setSuggestedThemes([]);

                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
                const imageWithoutPrefix = uploadedImage.split(',')[1];
                const textPrompt = getInspirationPrompt('zh-TW');
                const payload = { contents: [{ parts: [{ text: textPrompt }, { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }] }], generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "STRING" } } } };
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                    const result = await response.json(); const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (jsonText) setSuggestedThemes(JSON.parse(jsonText)); else throw new Error("API did not return valid theme suggestions.");
                } catch (err) { setError(t('error_inspiration_failed') + " (" + err.message + ")"); }
                finally { setIsSuggestingThemes(false); }
            };

            const handleLoadSession = (session) => {
                setUploadedImage(session.uploadedImage);
                setGeneratedImages(session.generatedImages);
                setCustomStickerPack(session.settings.activeStickerPack === defaultStickerPack.prompts ? [] : session.settings.activeStickerPack);
                setIsAnimeStyle(session.settings.isAnimeStyle);
                setAddText(session.settings.addText);
                setProcessedImages([]);
                setIsHistoryPanelOpen(false);
                setTimeout(() => { resultsRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 100);
            };

            const handleDeleteSession = async (id) => {
                try {
                    await deleteSessionFromDB(id);
                    setHistory(prev => prev.filter(session => session.id !== id));
                } catch (err) {
                    setError(t('error_db_delete'));
                }
            };

            const handleExportHistory = async () => {
                try {
                    const allHistory = await loadHistoryFromDB();
                    if (allHistory.length === 0) return;
                    const jsonString = JSON.stringify(allHistory, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `sticker_history_${new Date().toISOString().slice(0, 10)}.ocs`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                } catch (e) {
                    setError(t('history_export_error'));
                }
            };

            const handleImportClick = () => {
                importFileRef.current?.click();
            };

            const handleFileImport = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const content = e.target.result;
                        const importedHistory = JSON.parse(content);
                        if (!Array.isArray(importedHistory)) throw new Error("Invalid format");

                        for (const session of importedHistory) {
                            if (session.timestamp && session.uploadedImage && session.generatedImages) {
                                const { id, ...sessionToSave } = session;
                                await saveSessionToDB(sessionToSave);
                            }
                        }
                        const updatedHistory = await loadHistoryFromDB();
                        setHistory(updatedHistory);
                        // Maybe add a temporary success message state instead of alert
                    } catch (err) {
                        setError(t('history_import_error'));
                    } finally {
                        if (event.target) event.target.value = null;
                    }
                };
                reader.readAsText(file);
            };


            const progress = generatedImages.length > 0 ? (generatedImages.filter(img => img.status !== 'pending').length / generatedImages.length) * 100 : 0;

            return (
                <>
                    <div className="bg-gradient-to-b from-[#1B1B1B] via-[#262626] to-[#1B1B1B] text-[#E0E0E0] min-h-screen relative overflow-hidden">
                        <div className="fixed top-0 left-0 w-full h-full aurora-bg pointer-events-none z-0"></div>

                        {/* 頂部裝飾線 (模擬機艙頂部燈光) */}
                        <div className="fixed top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-[#BFA37C] to-transparent opacity-50 z-20"></div>

                        <div className="relative z-10 flex flex-col items-center p-4 sm:p-6 pb-20">
                            <ErrorNotification message={error} onDismiss={() => setError(null)} />

                            <div className="w-full max-w-6xl mx-auto">
                                <header className="my-12 w-full flex items-center justify-between">
                                    <div className="flex-1 flex justify-start items-center">
                                        <button onClick={() => setIsHistoryPanelOpen(true)} className="hidden sm:flex items-center gap-2 text-[#CCC] hover:text-[#BFA37C] transition-colors p-2 rounded-full hover:bg-white/5" aria-label={t('history_title')}>
                                            <IconHistory />
                                            <span className="hidden lg:inline font-medium tracking-wide">{t('history_title')}</span>
                                        </button>
                                    </div>
                                    <div className="flex-1 text-center">
                                        <h1 className="text-3xl sm:text-5xl md:text-6xl font-bold tracking-tight whitespace-nowrap flex justify-center items-baseline drop-shadow-lg">
                                            <span className="bg-clip-text text-transparent bg-gradient-to-b from-[#E0E0E0] to-[#999]">
                                                {t('title').includes('Sticker V3') ? t('title').split('Sticker V3')[0] : t('title')}
                                            </span>
                                            {t('title').includes('Sticker V3') && (
                                                <span className="text-[#BFA37C] ml-2 drop-shadow-[0_0_10px_rgba(191,163,124,0.3)]">Sticker V3</span>
                                            )}
                                        </h1>
                                        <p className="mt-4 text-base sm:text-lg text-[#888] tracking-widest uppercase">{t('subtitle')}</p>
                                        <div className="mt-4 inline-block bg-[#2A2A2A] text-[#BFA37C] font-bold text-[10px] sm:text-xs px-3 py-1 rounded border border-[#BFA37C]/50 shadow-[0_0_15px_rgba(191,163,124,0.2)] transform cursor-default z-20 whitespace-nowrap tracking-widest">
                                            NANO BANANA PRO
                                        </div>
                                    </div>
                                    <div className="flex-1 flex justify-end items-center gap-2">

                                        <button onClick={() => setIsApiKeyModalOpen(true)} className="flex items-center gap-2 text-[#CCC] hover:text-[#BFA37C] transition-colors p-2 rounded-full hover:bg-white/5" title="API Key Settings">
                                            <IconKey />
                                        </button>
                                    </div>
                                </header>

                                <main>
                                    <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} className="bg-[#222]/60 backdrop-blur-xl p-6 sm:p-8 rounded-3xl shadow-2xl border border-[#444] mb-12 sm:mb-16 relative overflow-hidden">
                                        {/* 裝飾性背景光 */}
                                        <div className="absolute top-0 right-0 w-64 h-64 bg-[#BFA37C] opacity-5 rounded-full filter blur-3xl pointer-events-none transform translate-x-1/2 -translate-y-1/2"></div>

                                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 sm:gap-10">
                                            <div>
                                                <h2 className="text-2xl font-semibold mb-6 text-[#E0E0E0] tracking-wide border-l-4 border-[#BFA37C] pl-3">{t('upload_title')}</h2>
                                                <div className="w-full aspect-square border-2 border-dashed border-[#555] rounded-xl flex items-center justify-center cursor-pointer hover:border-[#BFA37C] transition-all bg-[#1A1A1A] overflow-hidden shadow-inner relative group" onClick={() => !uploadedImage && fileInputRef.current?.click()}>
                                                    {isUploading ? <div className="flex flex-col items-center"><div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-[#BFA37C]"></div><p className="text-[#999] mt-4">{t('generating')}</p></div> : uploadedImage ? <img src={uploadedImage} alt="上傳預覽" className="w-full h-full object-cover" /> : <div className="flex flex-col items-center justify-center p-6 text-center text-[#666] transition-colors group-hover:text-[#BFA37C]"><IconUpload /><p className="mt-4 text-lg text-[#CCC] group-hover:text-[#BFA37C] transition-colors">{t('upload_click')}</p><p className="mt-4 text-sm">{t('upload_or')}</p><Button onClick={(e) => { e.stopPropagation(); setIsCameraOpen(true); }} className="mt-2 text-sm px-4 py-2 bg-[#333] border-[#555] text-[#CCC] hover:bg-[#444] hover:text-[#BFA37C] hover:border-[#BFA37C]"><div className="flex items-center gap-2"><IconCamera /><span>{t('upload_camera')}</span></div></Button></div>}
                                                    {uploadedImage && !isUploading && (<div className="absolute inset-0 bg-black/80 flex flex-col sm:flex-row gap-4 items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300"><Button onClick={() => fileInputRef.current?.click()}>{t('upload_change_file')}</Button><Button onClick={() => setIsCameraOpen(true)}><div className="flex items-center justify-center gap-2"><IconCamera /><span>{t('upload_camera')}</span></div></Button></div>)}
                                                </div>
                                                <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/png, image/jpeg" className="hidden" />
                                            </div>
                                            <div>
                                                <h2 className="text-2xl font-semibold mb-6 text-[#E0E0E0] tracking-wide border-l-4 border-[#BFA37C] pl-3">{t('stickers_title')}</h2>
                                                <div className="bg-[#1A1A1A] p-5 rounded-lg border border-[#333] mb-6 shadow-inner">
                                                    <h3 className="font-semibold text-lg mb-2 text-[#BFA37C] flex items-center gap-2"><IconSparkles /> {t('generator_title')}</h3><p className="text-[#999] text-sm mb-4 leading-relaxed">{t('generator_desc')}</p>
                                                    <div className="mb-4"><Button onClick={handleGetInspirationFromImage} disabled={!uploadedImage || isSuggestingThemes} className="w-full bg-[#333] hover:bg-[#444] border-[#555] hover:border-[#BFA37C] text-[#CCC] hover:text-[#BFA37C]"><div className="flex items-center justify-center gap-2">{isSuggestingThemes ? <><div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-[#CCC]"></div><span>{t('generator_analyzing')}</span></> : <span>{t('generator_inspiration_btn')}</span>}</div></Button>{suggestedThemes.length > 0 && (<div className="flex flex-wrap gap-2 mt-3">{suggestedThemes.map(theme => (<button key={theme} onClick={() => { setCustomIdeaInput(theme); }} className="px-3 py-1 bg-[#2F3E35] text-[#BFA37C] border border-[#4A5D4F] text-xs rounded-full hover:bg-[#3C4A3E] transition-colors">{theme}</button>))}</div>)}</div>
                                                    <textarea value={customIdeaInput} onChange={(e) => setCustomIdeaInput(e.target.value)} placeholder={t('generator_placeholder')} className="w-full bg-[#111] border border-[#444] rounded-lg py-3 px-4 focus:outline-none focus:ring-1 focus:ring-[#BFA37C] text-[#E0E0E0] text-sm placeholder-gray-700" rows="2" />
                                                    <div className="my-4">
                                                        <p className="text-xs text-[#888] text-center mb-2 tracking-wide">生成數量 / BATCH SIZE</p>
                                                        <div className="flex items-center gap-2 bg-[#111] p-1 rounded-full border border-[#333]">
                                                            {[8, 16, 24, 32, 40].map(num => (
                                                                <button
                                                                    key={num}
                                                                    onClick={() => setNumIdeasToGenerate(num)}
                                                                    className={`flex-1 text-center py-1.5 text-xs font-semibold rounded-full transition-all ${numIdeasToGenerate === num
                                                                        ? 'bg-[#BFA37C] text-[#1B1B1B] shadow-md'
                                                                        : 'text-[#666] hover:text-[#CCC] hover:bg-[#222]'
                                                                        }`}
                                                                >
                                                                    {num}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    <Button onClick={handleGenerateIdeas} disabled={isGeneratingIdeas} primary className="w-full mt-2"><div className="flex items-center justify-center gap-2">{isGeneratingIdeas ? <><div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-[#2A1E11]"></div><span>{t('generator_generating')}</span></> : t('generator_generate_ideas_btn')}</div></Button>
                                                </div>
                                                <div className="flex justify-between items-center mb-4"><p className="text-[#999] text-sm tracking-wide">{t('select_reactions')}</p>{customStickerPack.length > 0 && (<button onClick={() => { setCustomStickerPack([]); setSelectedStickers(defaultStickerPack.prompts.map(p => p.id)); }} className="text-xs text-[#BFA37C] hover:text-[#D4B384] underline underline-offset-4">{t('back_to_default')}</button>)}</div>
                                                <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
                                                    {activeStickerPack.map(prompt => (<label key={prompt.id} className={`cursor-pointer p-3 rounded-lg border text-center transition-all duration-300 ${selectedStickers.includes(prompt.id) ? 'bg-[#2F3E35] border-[#BFA37C] text-[#BFA37C] shadow-[0_0_10px_rgba(191,163,124,0.1)]' : 'bg-[#1A1A1A] border-[#333] hover:border-[#666] text-[#888]'}`}><input type="checkbox" checked={selectedStickers.includes(prompt.id)} onChange={() => handleStickerSelection(prompt.id)} className="hidden" /><span className="font-medium text-xs tracking-wide">{customStickerPack.length > 0 ? prompt.id : t(prompt.id)}</span></label>))}
                                                </div>
                                                <div className="flex flex-col sm:flex-row items-start sm:items-center gap-6 mt-6 pt-4 border-t border-[#333]">
                                                    <ToggleSwitch id="isAnimeStyleCheck" checked={isAnimeStyle} onChange={(e) => setIsAnimeStyle(e.target.checked)} label={t('option_anime')} />
                                                    <ToggleSwitch id="addTextCheck" checked={addText} onChange={(e) => setAddText(e.target.checked)} label={t('option_add_text')} />
                                                </div>
                                            </div>
                                        </div>
                                        <div className="mt-12 text-center">
                                            <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
                                                <Button onClick={handleGenerateClick} disabled={!uploadedImage || isLoading || isUploading} primary className="text-lg px-12 py-4 shadow-[0_0_20px_rgba(191,163,124,0.15)]"><div className="flex items-center gap-3">{isLoading ? <><div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-[#2A1E11]"></div>{`${t('generating_stickers')} (${Math.round(progress)}%)`}</> : <><IconSparkles />{t('generate_stickers_btn')}</>}</div></Button>
                                                {!isLoading && generatedImages.some(img => img.status === 'success') && (<div className="flex flex-col items-center gap-2"><Button onClick={handleRemoveBackground} disabled={isRemovingBackground} secondary className="text-lg px-8 py-4"><div className="flex items-center gap-3">{isRemovingBackground ? <><div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-[#E0E0E0]"></div>{`${t('removing_bg')} (${Math.round(removeBgProgress)}%)`}</> : <><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M9.53 16.122a3 3 0 0 0-5.78 1.128 2.25 2.25 0 0 1-2.4 2.245 4.5 4.5 0 0 0 8.4-2.245c0-.399-.078-.78-.22-1.128Zm0 0a15.998 15.998 0 0 0 3.388-1.62m-5.043-.025a15.994 15.994 0 0 1 1.622-3.395m3.42 3.42a15.995 15.995 0 0 0 4.764-4.648l3.876-3.876a1.5 1.5 0 0 0-4.471-4.471L9.53 16.122ZM21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /></svg>{t('remove_bg_btn')}</>}</div ></Button><p className="text-xs text-[#666] text-center max-w-xs">{t('remove_bg_desc')}</p></div>)}
                                            </div>
                                            {isRemovingBackground && (<div className="w-full max-w-md mx-auto mt-6"><div className="bg-[#111] rounded-full h-2 overflow-hidden shadow-inner border border-[#333]"><motion.div className="bg-[#BFA37C] h-2 rounded-full shadow-[0_0_10px_#BFA37C]" initial={{ width: 0 }} animate={{ width: `${removeBgProgress}%` }} transition={{ duration: 0.3 }} /></div><p className="text-[#BFA37C] mt-2 text-xs tracking-widest">{t('removing_bg')}...</p></div>)}
                                        </div>
                                    </motion.div>
                                    <div ref={resultsRef}>
                                        {(isLoading || generatedImages.length > 0) && (
                                            <div className="mt-16">
                                                <h2 className="text-3xl font-bold text-[#E0E0E0] mb-8 text-center tracking-widest border-b border-[#333] pb-4 inline-block px-12 relative">
                                                    {t('your_generated_stickers')}
                                                    <div className="absolute bottom-0 left-0 w-full h-[2px] bg-gradient-to-r from-transparent via-[#BFA37C] to-transparent"></div>
                                                </h2>
                                                {isLoading && (<div className="w-full max-w-4xl mx-auto mb-8 text-center"><div className="bg-[#111] rounded-full h-1 overflow-hidden shadow-inner border border-[#333]"><motion.div className="bg-[#BFA37C] h-1 rounded-full shadow-[0_0_10px_#BFA37C]" initial={{ width: 0 }} animate={{ width: `${progress}%` }} transition={{ duration: 0.5 }} /></div><p className="text-[#888] mt-4 text-xs tracking-wide">{t('keep_window_open')}</p></div>)}
                                                <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 sm:gap-6 mt-8">
                                                    {generatedImages.map((img, index) => {
                                                        const emotionDisplay = customStickerPack.length > 0 ? img.id : t(img.id);
                                                        switch (img.status) {
                                                            case 'success':
                                                                const processedImg = processedImages.find(p => p.id === img.id);
                                                                const displayImageUrl = processedImg ? processedImg.processedImageUrl : img.imageUrl;
                                                                const isProcessed = !!processedImg?.isProcessed;
                                                                return <StickerDisplay key={`${img.id}-${index}-success`} emotion={emotionDisplay} imageUrl={displayImageUrl} onDownload={(url, emotion) => handleDownloadRequest(url, img.id, isProcessed)} onRegenerate={() => regenerateImageAtIndex(index)} isProcessed={isProcessed} />;
                                                            case 'failed':
                                                                return <ErrorCard key={`${img.id}-${index}-failed`} emotion={emotionDisplay} onRegenerate={() => regenerateImageAtIndex(index)} />;
                                                            default:
                                                                return <LoadingCard key={`${img.id}-${index}-pending`} emotion={emotionDisplay} />;
                                                        }
                                                    })}
                                                </div>
                                            </div>
                                        )}
                                        {!isLoading && generatedImages.length > 0 && (<div className="text-center mt-16 mb-12 flex flex-col sm:flex-row items-center justify-center gap-6 flex-wrap"><Button onClick={handleStartOver}>{t('start_over')}</Button><Button onClick={handleDownloadAllAsZip} primary disabled={isZipping}><div className="flex items-center gap-2">{isZipping ? <><div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-[#2A1E11]"></div><span>{t('zipping')}</span></> : <><IconZip /><span>{t('download_zip')}</span></>}</div></Button> <a href="https://www.youtube.com/shorts/Nadvdw7vDdM" target="_blank" rel="noopener noreferrer"><Button secondary><div className="flex items-center gap-2"><IconUploadToStore /><span>{t('line_store_upload')}</span></div></Button></a></div>)}
                                    </div>
                                </main>
                                <AppFooter currentVersion={CURRENT_VERSION} />
                            </div>
                        </div>
                        {/* 手機版浮動選單 (更換顏色) */}
                        <div className="sm:hidden fixed bottom-4 left-4 z-30 flex flex-col items-center gap-3">

                            <button onClick={() => setIsHistoryPanelOpen(true)} className="p-4 rounded-full bg-[#1A1A1A] border border-[#BFA37C] text-[#BFA37C] shadow-lg" aria-label={t('history_title')}>
                                <IconHistory />
                            </button>
                            <button onClick={() => setIsApiKeyModalOpen(true)} className="p-4 rounded-full bg-[#C6A678] text-[#2A1E11] shadow-lg" aria-label="API Key">
                                <IconKey />
                            </button>
                        </div>
                    </div>
                    <CameraModal isOpen={isCameraOpen} onClose={() => setIsCameraOpen(false)} onCapture={handleCaptureConfirm} />
                    <HistoryPanel t={t} isOpen={isHistoryPanelOpen} onClose={() => setIsHistoryPanelOpen(false)} history={history} onLoadSession={handleLoadSession} onDeleteSession={handleDeleteSession} onExportHistory={handleExportHistory} onImportHistory={handleImportClick} />

                    <VersionCheckModal t={t} info={versionMismatchInfo} onClose={() => setVersionMismatchInfo(null)} />
                    <ApiKeyModal t={t} isOpen={isApiKeyModalOpen} onClose={() => setIsApiKeyModalOpen(false)} onSave={handleSaveApiKey} currentKey={userApiKey} />
                    <input type="file" ref={importFileRef} accept=".ocs" className="hidden" onChange={handleFileImport} />
                </>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>